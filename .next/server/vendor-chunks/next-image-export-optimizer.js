"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/next-image-export-optimizer";
exports.ids = ["vendor-chunks/next-image-export-optimizer"];
exports.modules = {

/***/ "(ssr)/./node_modules/next-image-export-optimizer/dist/ExportedImage.js":
/*!************************************************************************!*\
  !*** ./node_modules/next-image-export-optimizer/dist/ExportedImage.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/image */ \"(ssr)/./node_modules/next/dist/api/image.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\nconst splitFilePath = ({ filePath })=>{\n    const filenameWithExtension = filePath.split(\"\\\\\").pop()?.split(\"/\").pop() || \"\";\n    const filePathWithoutFilename = filePath.split(filenameWithExtension).shift();\n    const fileExtension = filePath.split(\".\").pop();\n    const filenameWithoutExtension = filenameWithExtension.substring(0, filenameWithExtension.lastIndexOf(\".\")) || filenameWithExtension;\n    return {\n        path: filePathWithoutFilename,\n        filename: filenameWithoutExtension,\n        extension: fileExtension || \"\"\n    };\n};\nconst generateImageURL = (src, width, basePath, isRemoteImage = false)=>{\n    const { filename, path, extension } = splitFilePath({\n        filePath: src\n    });\n    const useWebp =  true ? \"true\" == \"true\" : 0;\n    if (![\n        \"JPG\",\n        \"JPEG\",\n        \"WEBP\",\n        \"PNG\",\n        \"AVIF\",\n        \"GIF\"\n    ].includes(extension.toUpperCase())) {\n        // The images has an unsupported extension\n        // We will return the src\n        return src;\n    }\n    // If the images are stored as WEBP by the package, then we should change\n    // the extension to WEBP to load them correctly\n    let processedExtension = extension;\n    if (useWebp && [\n        \"JPG\",\n        \"JPEG\",\n        \"PNG\",\n        \"GIF\"\n    ].includes(extension.toUpperCase())) {\n        processedExtension = \"WEBP\";\n    }\n    let correctedPath = path;\n    const lastChar = correctedPath?.substr(-1); // Selects the last character\n    if (lastChar != \"/\") {\n        // If the last character is not a slash\n        correctedPath = correctedPath + \"/\"; // Append a slash to it.\n    }\n    const isStaticImage = src.includes(\"_next/static/media\");\n    if (basePath) {\n        if (basePath.endsWith(\"/\") && correctedPath && correctedPath.startsWith(\"/\")) {\n            correctedPath = basePath + correctedPath.slice(1);\n        } else if (!basePath.endsWith(\"/\") && correctedPath && !correctedPath.startsWith(\"/\")) {\n            correctedPath = basePath + \"/\" + correctedPath;\n        } else {\n            correctedPath = basePath + correctedPath;\n        }\n    }\n    const exportFolderName = \"nextImageExportOptimizer\" || 0;\n    const basePathPrefixForStaticImages = basePath ? basePath + \"/\" : \"\";\n    let generatedImageURL = `${isStaticImage ? basePathPrefixForStaticImages : correctedPath}${exportFolderName}/${filename}-opt-${width}.${processedExtension.toUpperCase()}`;\n    // if the generatedImageURL is not starting with a slash, then we add one as long as it is not a remote image\n    if (!isRemoteImage && generatedImageURL.charAt(0) !== \"/\") {\n        generatedImageURL = \"/\" + generatedImageURL;\n    }\n    return generatedImageURL;\n};\n// Credits to https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js\n// This is a hash function that is used to generate a hash from the image URL\nconst hashAlgorithm = (str, seed = 0)=>{\n    let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;\n    for(let i = 0, ch; i < str.length; i++){\n        ch = str.charCodeAt(i);\n        h1 = Math.imul(h1 ^ ch, 2654435761);\n        h2 = Math.imul(h2 ^ ch, 1597334677);\n    }\n    h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507);\n    h1 ^= Math.imul(h2 ^ h2 >>> 13, 3266489909);\n    h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);\n    h2 ^= Math.imul(h1 ^ h1 >>> 13, 3266489909);\n    return 4294967296 * (2097151 & h2) + (h1 >>> 0);\n};\nfunction urlToFilename(url) {\n    try {\n        const parsedUrl = new URL(url);\n        const extension = parsedUrl.pathname.split(\".\").pop();\n        if (extension) {\n            return hashAlgorithm(url).toString().concat(\".\", extension);\n        }\n    } catch (error) {\n        console.error(\"Error parsing URL\", url, error);\n    }\n    return hashAlgorithm(url).toString();\n}\nconst imageURLForRemoteImage = ({ src, width, basePath })=>{\n    const encodedSrc = urlToFilename(src);\n    return generateImageURL(encodedSrc, width, basePath, true);\n};\nconst optimizedLoader = ({ src, width, basePath })=>{\n    const isStaticImage = typeof src === \"object\";\n    const _src = isStaticImage ? src.src : src;\n    const originalImageWidth = isStaticImage && src.width || undefined;\n    // if it is a static image, we can use the width of the original image to generate a reduced srcset that returns\n    // the same image url for widths that are larger than the original image\n    if (isStaticImage && originalImageWidth && width > originalImageWidth) {\n        const deviceSizes = ({\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image/\",\"loader\":\"custom\",\"dangerouslyAllowSVG\":false,\"unoptimized\":true,\"domains\":[],\"remotePatterns\":[],\"output\":\"export\"}?.deviceSizes || [\n            640,\n            750,\n            828,\n            1080,\n            1200,\n            1920,\n            2048,\n            3840\n        ]).map(Number);\n        const imageSizes = ({\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image/\",\"loader\":\"custom\",\"dangerouslyAllowSVG\":false,\"unoptimized\":true,\"domains\":[],\"remotePatterns\":[],\"output\":\"export\"}?.imageSizes || [\n            16,\n            32,\n            48,\n            64,\n            96,\n            128,\n            256,\n            384\n        ]).map(Number);\n        let allSizes = [\n            ...deviceSizes,\n            ...imageSizes\n        ];\n        allSizes = allSizes.filter((v, i, a)=>a.indexOf(v) === i);\n        allSizes.sort((a, b)=>a - b);\n        // only use the width if it is smaller or equal to the next size in the allSizes array\n        let nextLargestSize = null;\n        for(let i = 0; i < allSizes.length; i++){\n            if (Number(allSizes[i]) >= originalImageWidth && (nextLargestSize === null || Number(allSizes[i]) < nextLargestSize)) {\n                nextLargestSize = Number(allSizes[i]);\n            }\n        }\n        if (nextLargestSize !== null) {\n            return generateImageURL(_src, nextLargestSize, basePath);\n        }\n    }\n    // Check if the image is a remote image (starts with http or https)\n    if (_src.startsWith(\"http\")) {\n        return imageURLForRemoteImage({\n            src: _src,\n            width,\n            basePath\n        });\n    }\n    return generateImageURL(_src, width, basePath);\n};\nconst fallbackLoader = ({ src })=>{\n    let _src = typeof src === \"object\" ? src.src : src;\n    const isRemoteImage = _src.startsWith(\"http\");\n    // if the _src does not start with a slash, then we add one as long as it is not a remote image\n    if (!isRemoteImage && _src.charAt(0) !== \"/\") {\n        _src = \"/\" + _src;\n    }\n    return _src;\n};\nconst ExportedImage = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({ src, priority = false, loading, className, width, height, onLoad, unoptimized, placeholder = \"blur\", basePath = \"\", alt = \"\", blurDataURL, style, onError, overrideSrc, ...rest }, ref)=>{\n    const [imageError, setImageError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const automaticallyCalculatedBlurDataURL = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (blurDataURL) {\n            // use the user provided blurDataURL if present\n            return blurDataURL;\n        }\n        // check if the src is specified as a local file -> then it is an object\n        const isStaticImage = typeof src === \"object\";\n        let _src = isStaticImage ? src.src : src;\n        if (unoptimized === true) {\n            // return the src image when unoptimized\n            return _src;\n        }\n        // Check if the image is a remote image (starts with http or https)\n        if (_src.startsWith(\"http\")) {\n            return imageURLForRemoteImage({\n                src: _src,\n                width: 10,\n                basePath\n            });\n        }\n        // otherwise use the generated image of 10px width as a blurDataURL\n        return generateImageURL(_src, 10, basePath);\n    }, [\n        blurDataURL,\n        src,\n        unoptimized,\n        basePath\n    ]);\n    // check if the src is a SVG image -> then we should not use the blurDataURL and use unoptimized\n    const isSVG = typeof src === \"object\" ? src.src.endsWith(\".svg\") : src.endsWith(\".svg\");\n    const [blurComplete, setBlurComplete] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Currently, we have to handle the blurDataURL ourselves as the new Image component\n    // is expecting a base64 encoded string, but the generated blurDataURL is a normal URL\n    const blurStyle = placeholder === \"blur\" && !isSVG && automaticallyCalculatedBlurDataURL && automaticallyCalculatedBlurDataURL.startsWith(\"/\") && !blurComplete ? {\n        backgroundSize: style?.objectFit || \"cover\",\n        backgroundPosition: style?.objectPosition || \"50% 50%\",\n        backgroundRepeat: \"no-repeat\",\n        backgroundImage: `url(\"${automaticallyCalculatedBlurDataURL}\")`\n    } : undefined;\n    const isStaticImage = typeof src === \"object\";\n    let _src = isStaticImage ? src.src : src;\n    if (basePath && !isStaticImage && _src.startsWith(\"/\")) {\n        _src = basePath + _src;\n    }\n    if (basePath && !isStaticImage && !_src.startsWith(\"/\")) {\n        _src = basePath + \"/\" + _src;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(next_image__WEBPACK_IMPORTED_MODULE_0__[\"default\"], {\n        ref: ref,\n        alt: alt,\n        ...rest,\n        ...width && {\n            width\n        },\n        ...height && {\n            height\n        },\n        ...loading && {\n            loading\n        },\n        ...className && {\n            className\n        },\n        ...onLoad && {\n            onLoad\n        },\n        ...overrideSrc && {\n            overrideSrc\n        },\n        ...placeholder && {\n            placeholder: blurStyle || blurComplete ? \"empty\" : placeholder\n        },\n        ...unoptimized && {\n            unoptimized\n        },\n        ...priority && {\n            priority\n        },\n        ...isSVG && {\n            unoptimized: true\n        },\n        style: {\n            ...style,\n            ...blurStyle\n        },\n        loader: imageError || unoptimized === true ? ()=>fallbackLoader({\n                src: overrideSrc || src\n            }) : (e)=>optimizedLoader({\n                src,\n                width: e.width,\n                basePath\n            }),\n        blurDataURL: automaticallyCalculatedBlurDataURL,\n        onError: (error)=>{\n            setImageError(true);\n            setBlurComplete(true);\n            // execute the onError function if provided\n            onError && onError(error);\n        },\n        onLoad: (e)=>{\n            // for some configurations, the onError handler is not called on an error occurrence\n            // so we need to check if the image is loaded correctly\n            const target = e.target;\n            if (target.naturalWidth === 0) {\n                // Broken image, fall back to unoptimized (meaning the original image src)\n                setImageError(true);\n            }\n            setBlurComplete(true);\n            // execute the onLoad callback if present\n            onLoad && onLoad(e);\n        },\n        src: isStaticImage ? src : _src\n    });\n});\nExportedImage.displayName = \"ExportedImage\";\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExportedImage);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC1pbWFnZS1leHBvcnQtb3B0aW1pemVyL2Rpc3QvRXhwb3J0ZWRJbWFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OzZEQUMrQjtBQUM4QjtBQUM3RCxNQUFNSyxnQkFBZ0IsQ0FBQyxFQUFFQyxRQUFRLEVBQUU7SUFDL0IsTUFBTUMsd0JBQXdCRCxTQUFTRSxLQUFLLENBQUMsTUFBTUMsR0FBRyxJQUFJRCxNQUFNLEtBQUtDLFNBQVM7SUFDOUUsTUFBTUMsMEJBQTBCSixTQUFTRSxLQUFLLENBQUNELHVCQUF1QkksS0FBSztJQUMzRSxNQUFNQyxnQkFBZ0JOLFNBQVNFLEtBQUssQ0FBQyxLQUFLQyxHQUFHO0lBQzdDLE1BQU1JLDJCQUEyQk4sc0JBQXNCTyxTQUFTLENBQUMsR0FBR1Asc0JBQXNCUSxXQUFXLENBQUMsU0FBU1I7SUFDL0csT0FBTztRQUNIUyxNQUFNTjtRQUNOTyxVQUFVSjtRQUNWSyxXQUFXTixpQkFBaUI7SUFDaEM7QUFDSjtBQUNBLE1BQU1PLG1CQUFtQixDQUFDQyxLQUFLQyxPQUFPQyxVQUFVQyxnQkFBZ0IsS0FBSztJQUNqRSxNQUFNLEVBQUVOLFFBQVEsRUFBRUQsSUFBSSxFQUFFRSxTQUFTLEVBQUUsR0FBR2IsY0FBYztRQUFFQyxVQUFVYztJQUFJO0lBQ3BFLE1BQU1JLFVBQVVDLEtBQXFFRyxHQUMvRUgsTUFBd0QsSUFBSSxTQUM1RCxDQUFJO0lBQ1YsSUFBSSxDQUFDO1FBQUM7UUFBTztRQUFRO1FBQVE7UUFBTztRQUFRO0tBQU0sQ0FBQ0ksUUFBUSxDQUFDWCxVQUFVWSxXQUFXLEtBQUs7UUFDbEYsMENBQTBDO1FBQzFDLHlCQUF5QjtRQUN6QixPQUFPVjtJQUNYO0lBQ0EseUVBQXlFO0lBQ3pFLCtDQUErQztJQUMvQyxJQUFJVyxxQkFBcUJiO0lBQ3pCLElBQUlNLFdBQ0E7UUFBQztRQUFPO1FBQVE7UUFBTztLQUFNLENBQUNLLFFBQVEsQ0FBQ1gsVUFBVVksV0FBVyxLQUFLO1FBQ2pF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ZWpDLGFBQWFBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZGRpcy1wYXRoLXRyYWlsZXJzLy4vbm9kZV9tb2R1bGVzL25leHQtaW1hZ2UtZXhwb3J0LW9wdGltaXplci9kaXN0L0V4cG9ydGVkSW1hZ2UuanM/ZWYwMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcbmltcG9ydCBJbWFnZSBmcm9tIFwibmV4dC9pbWFnZVwiO1xuaW1wb3J0IFJlYWN0LCB7IGZvcndhcmRSZWYsIHVzZU1lbW8sIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5jb25zdCBzcGxpdEZpbGVQYXRoID0gKHsgZmlsZVBhdGggfSkgPT4ge1xuICAgIGNvbnN0IGZpbGVuYW1lV2l0aEV4dGVuc2lvbiA9IGZpbGVQYXRoLnNwbGl0KFwiXFxcXFwiKS5wb3AoKT8uc3BsaXQoXCIvXCIpLnBvcCgpIHx8IFwiXCI7XG4gICAgY29uc3QgZmlsZVBhdGhXaXRob3V0RmlsZW5hbWUgPSBmaWxlUGF0aC5zcGxpdChmaWxlbmFtZVdpdGhFeHRlbnNpb24pLnNoaWZ0KCk7XG4gICAgY29uc3QgZmlsZUV4dGVuc2lvbiA9IGZpbGVQYXRoLnNwbGl0KFwiLlwiKS5wb3AoKTtcbiAgICBjb25zdCBmaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24gPSBmaWxlbmFtZVdpdGhFeHRlbnNpb24uc3Vic3RyaW5nKDAsIGZpbGVuYW1lV2l0aEV4dGVuc2lvbi5sYXN0SW5kZXhPZihcIi5cIikpIHx8IGZpbGVuYW1lV2l0aEV4dGVuc2lvbjtcbiAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiBmaWxlUGF0aFdpdGhvdXRGaWxlbmFtZSxcbiAgICAgICAgZmlsZW5hbWU6IGZpbGVuYW1lV2l0aG91dEV4dGVuc2lvbixcbiAgICAgICAgZXh0ZW5zaW9uOiBmaWxlRXh0ZW5zaW9uIHx8IFwiXCIsXG4gICAgfTtcbn07XG5jb25zdCBnZW5lcmF0ZUltYWdlVVJMID0gKHNyYywgd2lkdGgsIGJhc2VQYXRoLCBpc1JlbW90ZUltYWdlID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCB7IGZpbGVuYW1lLCBwYXRoLCBleHRlbnNpb24gfSA9IHNwbGl0RmlsZVBhdGgoeyBmaWxlUGF0aDogc3JjIH0pO1xuICAgIGNvbnN0IHVzZVdlYnAgPSBwcm9jZXNzLmVudi5uZXh0SW1hZ2VFeHBvcnRPcHRpbWl6ZXJfc3RvcmVQaWN0dXJlc0luV0VCUCAhPSB1bmRlZmluZWRcbiAgICAgICAgPyBwcm9jZXNzLmVudi5uZXh0SW1hZ2VFeHBvcnRPcHRpbWl6ZXJfc3RvcmVQaWN0dXJlc0luV0VCUCA9PSBcInRydWVcIlxuICAgICAgICA6IHRydWU7XG4gICAgaWYgKCFbXCJKUEdcIiwgXCJKUEVHXCIsIFwiV0VCUFwiLCBcIlBOR1wiLCBcIkFWSUZcIiwgXCJHSUZcIl0uaW5jbHVkZXMoZXh0ZW5zaW9uLnRvVXBwZXJDYXNlKCkpKSB7XG4gICAgICAgIC8vIFRoZSBpbWFnZXMgaGFzIGFuIHVuc3VwcG9ydGVkIGV4dGVuc2lvblxuICAgICAgICAvLyBXZSB3aWxsIHJldHVybiB0aGUgc3JjXG4gICAgICAgIHJldHVybiBzcmM7XG4gICAgfVxuICAgIC8vIElmIHRoZSBpbWFnZXMgYXJlIHN0b3JlZCBhcyBXRUJQIGJ5IHRoZSBwYWNrYWdlLCB0aGVuIHdlIHNob3VsZCBjaGFuZ2VcbiAgICAvLyB0aGUgZXh0ZW5zaW9uIHRvIFdFQlAgdG8gbG9hZCB0aGVtIGNvcnJlY3RseVxuICAgIGxldCBwcm9jZXNzZWRFeHRlbnNpb24gPSBleHRlbnNpb247XG4gICAgaWYgKHVzZVdlYnAgJiZcbiAgICAgICAgW1wiSlBHXCIsIFwiSlBFR1wiLCBcIlBOR1wiLCBcIkdJRlwiXS5pbmNsdWRlcyhleHRlbnNpb24udG9VcHBlckNhc2UoKSkpIHtcbiAgICAgICAgcHJvY2Vzc2VkRXh0ZW5zaW9uID0gXCJXRUJQXCI7XG4gICAgfVxuICAgIGxldCBjb3JyZWN0ZWRQYXRoID0gcGF0aDtcbiAgICBjb25zdCBsYXN0Q2hhciA9IGNvcnJlY3RlZFBhdGg/LnN1YnN0cigtMSk7IC8vIFNlbGVjdHMgdGhlIGxhc3QgY2hhcmFjdGVyXG4gICAgaWYgKGxhc3RDaGFyICE9IFwiL1wiKSB7XG4gICAgICAgIC8vIElmIHRoZSBsYXN0IGNoYXJhY3RlciBpcyBub3QgYSBzbGFzaFxuICAgICAgICBjb3JyZWN0ZWRQYXRoID0gY29ycmVjdGVkUGF0aCArIFwiL1wiOyAvLyBBcHBlbmQgYSBzbGFzaCB0byBpdC5cbiAgICB9XG4gICAgY29uc3QgaXNTdGF0aWNJbWFnZSA9IHNyYy5pbmNsdWRlcyhcIl9uZXh0L3N0YXRpYy9tZWRpYVwiKTtcbiAgICBpZiAoYmFzZVBhdGgpIHtcbiAgICAgICAgaWYgKGJhc2VQYXRoLmVuZHNXaXRoKFwiL1wiKSAmJlxuICAgICAgICAgICAgY29ycmVjdGVkUGF0aCAmJlxuICAgICAgICAgICAgY29ycmVjdGVkUGF0aC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgICAgICAgY29ycmVjdGVkUGF0aCA9IGJhc2VQYXRoICsgY29ycmVjdGVkUGF0aC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghYmFzZVBhdGguZW5kc1dpdGgoXCIvXCIpICYmXG4gICAgICAgICAgICBjb3JyZWN0ZWRQYXRoICYmXG4gICAgICAgICAgICAhY29ycmVjdGVkUGF0aC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgICAgICAgY29ycmVjdGVkUGF0aCA9IGJhc2VQYXRoICsgXCIvXCIgKyBjb3JyZWN0ZWRQYXRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29ycmVjdGVkUGF0aCA9IGJhc2VQYXRoICsgY29ycmVjdGVkUGF0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBleHBvcnRGb2xkZXJOYW1lID0gcHJvY2Vzcy5lbnYubmV4dEltYWdlRXhwb3J0T3B0aW1pemVyX2V4cG9ydEZvbGRlck5hbWUgfHxcbiAgICAgICAgXCJuZXh0SW1hZ2VFeHBvcnRPcHRpbWl6ZXJcIjtcbiAgICBjb25zdCBiYXNlUGF0aFByZWZpeEZvclN0YXRpY0ltYWdlcyA9IGJhc2VQYXRoID8gYmFzZVBhdGggKyBcIi9cIiA6IFwiXCI7XG4gICAgbGV0IGdlbmVyYXRlZEltYWdlVVJMID0gYCR7aXNTdGF0aWNJbWFnZSA/IGJhc2VQYXRoUHJlZml4Rm9yU3RhdGljSW1hZ2VzIDogY29ycmVjdGVkUGF0aH0ke2V4cG9ydEZvbGRlck5hbWV9LyR7ZmlsZW5hbWV9LW9wdC0ke3dpZHRofS4ke3Byb2Nlc3NlZEV4dGVuc2lvbi50b1VwcGVyQ2FzZSgpfWA7XG4gICAgLy8gaWYgdGhlIGdlbmVyYXRlZEltYWdlVVJMIGlzIG5vdCBzdGFydGluZyB3aXRoIGEgc2xhc2gsIHRoZW4gd2UgYWRkIG9uZSBhcyBsb25nIGFzIGl0IGlzIG5vdCBhIHJlbW90ZSBpbWFnZVxuICAgIGlmICghaXNSZW1vdGVJbWFnZSAmJiBnZW5lcmF0ZWRJbWFnZVVSTC5jaGFyQXQoMCkgIT09IFwiL1wiKSB7XG4gICAgICAgIGdlbmVyYXRlZEltYWdlVVJMID0gXCIvXCIgKyBnZW5lcmF0ZWRJbWFnZVVSTDtcbiAgICB9XG4gICAgcmV0dXJuIGdlbmVyYXRlZEltYWdlVVJMO1xufTtcbi8vIENyZWRpdHMgdG8gaHR0cHM6Ly9naXRodWIuY29tL2JyeWMvY29kZS9ibG9iL21hc3Rlci9qc2hhc2gvZXhwZXJpbWVudGFsL2N5cmI1My5qc1xuLy8gVGhpcyBpcyBhIGhhc2ggZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGdlbmVyYXRlIGEgaGFzaCBmcm9tIHRoZSBpbWFnZSBVUkxcbmNvbnN0IGhhc2hBbGdvcml0aG0gPSAoc3RyLCBzZWVkID0gMCkgPT4ge1xuICAgIGxldCBoMSA9IDB4ZGVhZGJlZWYgXiBzZWVkLCBoMiA9IDB4NDFjNmNlNTcgXiBzZWVkO1xuICAgIGZvciAobGV0IGkgPSAwLCBjaDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBoMSA9IE1hdGguaW11bChoMSBeIGNoLCAyNjU0NDM1NzYxKTtcbiAgICAgICAgaDIgPSBNYXRoLmltdWwoaDIgXiBjaCwgMTU5NzMzNDY3Nyk7XG4gICAgfVxuICAgIGgxID0gTWF0aC5pbXVsKGgxIF4gKGgxID4+PiAxNiksIDIyNDY4MjI1MDcpO1xuICAgIGgxIF49IE1hdGguaW11bChoMiBeIChoMiA+Pj4gMTMpLCAzMjY2NDg5OTA5KTtcbiAgICBoMiA9IE1hdGguaW11bChoMiBeIChoMiA+Pj4gMTYpLCAyMjQ2ODIyNTA3KTtcbiAgICBoMiBePSBNYXRoLmltdWwoaDEgXiAoaDEgPj4+IDEzKSwgMzI2NjQ4OTkwOSk7XG4gICAgcmV0dXJuIDQyOTQ5NjcyOTYgKiAoMjA5NzE1MSAmIGgyKSArIChoMSA+Pj4gMCk7XG59O1xuZnVuY3Rpb24gdXJsVG9GaWxlbmFtZSh1cmwpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKHVybCk7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IHBhcnNlZFVybC5wYXRobmFtZS5zcGxpdChcIi5cIikucG9wKCk7XG4gICAgICAgIGlmIChleHRlbnNpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNoQWxnb3JpdGhtKHVybCkudG9TdHJpbmcoKS5jb25jYXQoXCIuXCIsIGV4dGVuc2lvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwYXJzaW5nIFVSTFwiLCB1cmwsIGVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc2hBbGdvcml0aG0odXJsKS50b1N0cmluZygpO1xufVxuY29uc3QgaW1hZ2VVUkxGb3JSZW1vdGVJbWFnZSA9ICh7IHNyYywgd2lkdGgsIGJhc2VQYXRoLCB9KSA9PiB7XG4gICAgY29uc3QgZW5jb2RlZFNyYyA9IHVybFRvRmlsZW5hbWUoc3JjKTtcbiAgICByZXR1cm4gZ2VuZXJhdGVJbWFnZVVSTChlbmNvZGVkU3JjLCB3aWR0aCwgYmFzZVBhdGgsIHRydWUpO1xufTtcbmNvbnN0IG9wdGltaXplZExvYWRlciA9ICh7IHNyYywgd2lkdGgsIGJhc2VQYXRoLCB9KSA9PiB7XG4gICAgY29uc3QgaXNTdGF0aWNJbWFnZSA9IHR5cGVvZiBzcmMgPT09IFwib2JqZWN0XCI7XG4gICAgY29uc3QgX3NyYyA9IGlzU3RhdGljSW1hZ2UgPyBzcmMuc3JjIDogc3JjO1xuICAgIGNvbnN0IG9yaWdpbmFsSW1hZ2VXaWR0aCA9IChpc1N0YXRpY0ltYWdlICYmIHNyYy53aWR0aCkgfHwgdW5kZWZpbmVkO1xuICAgIC8vIGlmIGl0IGlzIGEgc3RhdGljIGltYWdlLCB3ZSBjYW4gdXNlIHRoZSB3aWR0aCBvZiB0aGUgb3JpZ2luYWwgaW1hZ2UgdG8gZ2VuZXJhdGUgYSByZWR1Y2VkIHNyY3NldCB0aGF0IHJldHVybnNcbiAgICAvLyB0aGUgc2FtZSBpbWFnZSB1cmwgZm9yIHdpZHRocyB0aGF0IGFyZSBsYXJnZXIgdGhhbiB0aGUgb3JpZ2luYWwgaW1hZ2VcbiAgICBpZiAoaXNTdGF0aWNJbWFnZSAmJiBvcmlnaW5hbEltYWdlV2lkdGggJiYgd2lkdGggPiBvcmlnaW5hbEltYWdlV2lkdGgpIHtcbiAgICAgICAgY29uc3QgZGV2aWNlU2l6ZXMgPSAocHJvY2Vzcy5lbnYuX19ORVhUX0lNQUdFX09QVFM/LmRldmljZVNpemVzIHx8IFtcbiAgICAgICAgICAgIDY0MCwgNzUwLCA4MjgsIDEwODAsIDEyMDAsIDE5MjAsIDIwNDgsIDM4NDAsXG4gICAgICAgIF0pLm1hcChOdW1iZXIpO1xuICAgICAgICBjb25zdCBpbWFnZVNpemVzID0gKHByb2Nlc3MuZW52Ll9fTkVYVF9JTUFHRV9PUFRTPy5pbWFnZVNpemVzIHx8IFtcbiAgICAgICAgICAgIDE2LCAzMiwgNDgsIDY0LCA5NiwgMTI4LCAyNTYsIDM4NCxcbiAgICAgICAgXSkubWFwKE51bWJlcik7XG4gICAgICAgIGxldCBhbGxTaXplcyA9IFsuLi5kZXZpY2VTaXplcywgLi4uaW1hZ2VTaXplc107XG4gICAgICAgIGFsbFNpemVzID0gYWxsU2l6ZXMuZmlsdGVyKCh2LCBpLCBhKSA9PiBhLmluZGV4T2YodikgPT09IGkpO1xuICAgICAgICBhbGxTaXplcy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICAgIC8vIG9ubHkgdXNlIHRoZSB3aWR0aCBpZiBpdCBpcyBzbWFsbGVyIG9yIGVxdWFsIHRvIHRoZSBuZXh0IHNpemUgaW4gdGhlIGFsbFNpemVzIGFycmF5XG4gICAgICAgIGxldCBuZXh0TGFyZ2VzdFNpemUgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbFNpemVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoTnVtYmVyKGFsbFNpemVzW2ldKSA+PSBvcmlnaW5hbEltYWdlV2lkdGggJiZcbiAgICAgICAgICAgICAgICAobmV4dExhcmdlc3RTaXplID09PSBudWxsIHx8IE51bWJlcihhbGxTaXplc1tpXSkgPCBuZXh0TGFyZ2VzdFNpemUpKSB7XG4gICAgICAgICAgICAgICAgbmV4dExhcmdlc3RTaXplID0gTnVtYmVyKGFsbFNpemVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dExhcmdlc3RTaXplICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVJbWFnZVVSTChfc3JjLCBuZXh0TGFyZ2VzdFNpemUsIGJhc2VQYXRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDaGVjayBpZiB0aGUgaW1hZ2UgaXMgYSByZW1vdGUgaW1hZ2UgKHN0YXJ0cyB3aXRoIGh0dHAgb3IgaHR0cHMpXG4gICAgaWYgKF9zcmMuc3RhcnRzV2l0aChcImh0dHBcIikpIHtcbiAgICAgICAgcmV0dXJuIGltYWdlVVJMRm9yUmVtb3RlSW1hZ2UoeyBzcmM6IF9zcmMsIHdpZHRoLCBiYXNlUGF0aCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGdlbmVyYXRlSW1hZ2VVUkwoX3NyYywgd2lkdGgsIGJhc2VQYXRoKTtcbn07XG5jb25zdCBmYWxsYmFja0xvYWRlciA9ICh7IHNyYyB9KSA9PiB7XG4gICAgbGV0IF9zcmMgPSB0eXBlb2Ygc3JjID09PSBcIm9iamVjdFwiID8gc3JjLnNyYyA6IHNyYztcbiAgICBjb25zdCBpc1JlbW90ZUltYWdlID0gX3NyYy5zdGFydHNXaXRoKFwiaHR0cFwiKTtcbiAgICAvLyBpZiB0aGUgX3NyYyBkb2VzIG5vdCBzdGFydCB3aXRoIGEgc2xhc2gsIHRoZW4gd2UgYWRkIG9uZSBhcyBsb25nIGFzIGl0IGlzIG5vdCBhIHJlbW90ZSBpbWFnZVxuICAgIGlmICghaXNSZW1vdGVJbWFnZSAmJiBfc3JjLmNoYXJBdCgwKSAhPT0gXCIvXCIpIHtcbiAgICAgICAgX3NyYyA9IFwiL1wiICsgX3NyYztcbiAgICB9XG4gICAgcmV0dXJuIF9zcmM7XG59O1xuY29uc3QgRXhwb3J0ZWRJbWFnZSA9IGZvcndhcmRSZWYoKHsgc3JjLCBwcmlvcml0eSA9IGZhbHNlLCBsb2FkaW5nLCBjbGFzc05hbWUsIHdpZHRoLCBoZWlnaHQsIG9uTG9hZCwgdW5vcHRpbWl6ZWQsIHBsYWNlaG9sZGVyID0gXCJibHVyXCIsIGJhc2VQYXRoID0gXCJcIiwgYWx0ID0gXCJcIiwgYmx1ckRhdGFVUkwsIHN0eWxlLCBvbkVycm9yLCBvdmVycmlkZVNyYywgLi4ucmVzdCB9LCByZWYpID0+IHtcbiAgICBjb25zdCBbaW1hZ2VFcnJvciwgc2V0SW1hZ2VFcnJvcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgYXV0b21hdGljYWxseUNhbGN1bGF0ZWRCbHVyRGF0YVVSTCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoYmx1ckRhdGFVUkwpIHtcbiAgICAgICAgICAgIC8vIHVzZSB0aGUgdXNlciBwcm92aWRlZCBibHVyRGF0YVVSTCBpZiBwcmVzZW50XG4gICAgICAgICAgICByZXR1cm4gYmx1ckRhdGFVUkw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHNyYyBpcyBzcGVjaWZpZWQgYXMgYSBsb2NhbCBmaWxlIC0+IHRoZW4gaXQgaXMgYW4gb2JqZWN0XG4gICAgICAgIGNvbnN0IGlzU3RhdGljSW1hZ2UgPSB0eXBlb2Ygc3JjID09PSBcIm9iamVjdFwiO1xuICAgICAgICBsZXQgX3NyYyA9IGlzU3RhdGljSW1hZ2UgPyBzcmMuc3JjIDogc3JjO1xuICAgICAgICBpZiAodW5vcHRpbWl6ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUgc3JjIGltYWdlIHdoZW4gdW5vcHRpbWl6ZWRcbiAgICAgICAgICAgIHJldHVybiBfc3JjO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBpbWFnZSBpcyBhIHJlbW90ZSBpbWFnZSAoc3RhcnRzIHdpdGggaHR0cCBvciBodHRwcylcbiAgICAgICAgaWYgKF9zcmMuc3RhcnRzV2l0aChcImh0dHBcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBpbWFnZVVSTEZvclJlbW90ZUltYWdlKHsgc3JjOiBfc3JjLCB3aWR0aDogMTAsIGJhc2VQYXRoIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIG90aGVyd2lzZSB1c2UgdGhlIGdlbmVyYXRlZCBpbWFnZSBvZiAxMHB4IHdpZHRoIGFzIGEgYmx1ckRhdGFVUkxcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlSW1hZ2VVUkwoX3NyYywgMTAsIGJhc2VQYXRoKTtcbiAgICB9LCBbYmx1ckRhdGFVUkwsIHNyYywgdW5vcHRpbWl6ZWQsIGJhc2VQYXRoXSk7XG4gICAgLy8gY2hlY2sgaWYgdGhlIHNyYyBpcyBhIFNWRyBpbWFnZSAtPiB0aGVuIHdlIHNob3VsZCBub3QgdXNlIHRoZSBibHVyRGF0YVVSTCBhbmQgdXNlIHVub3B0aW1pemVkXG4gICAgY29uc3QgaXNTVkcgPSB0eXBlb2Ygc3JjID09PSBcIm9iamVjdFwiID8gc3JjLnNyYy5lbmRzV2l0aChcIi5zdmdcIikgOiBzcmMuZW5kc1dpdGgoXCIuc3ZnXCIpO1xuICAgIGNvbnN0IFtibHVyQ29tcGxldGUsIHNldEJsdXJDb21wbGV0ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgLy8gQ3VycmVudGx5LCB3ZSBoYXZlIHRvIGhhbmRsZSB0aGUgYmx1ckRhdGFVUkwgb3Vyc2VsdmVzIGFzIHRoZSBuZXcgSW1hZ2UgY29tcG9uZW50XG4gICAgLy8gaXMgZXhwZWN0aW5nIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nLCBidXQgdGhlIGdlbmVyYXRlZCBibHVyRGF0YVVSTCBpcyBhIG5vcm1hbCBVUkxcbiAgICBjb25zdCBibHVyU3R5bGUgPSBwbGFjZWhvbGRlciA9PT0gXCJibHVyXCIgJiZcbiAgICAgICAgIWlzU1ZHICYmXG4gICAgICAgIGF1dG9tYXRpY2FsbHlDYWxjdWxhdGVkQmx1ckRhdGFVUkwgJiZcbiAgICAgICAgYXV0b21hdGljYWxseUNhbGN1bGF0ZWRCbHVyRGF0YVVSTC5zdGFydHNXaXRoKFwiL1wiKSAmJlxuICAgICAgICAhYmx1ckNvbXBsZXRlXG4gICAgICAgID8ge1xuICAgICAgICAgICAgYmFja2dyb3VuZFNpemU6IHN0eWxlPy5vYmplY3RGaXQgfHwgXCJjb3ZlclwiLFxuICAgICAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uOiBzdHlsZT8ub2JqZWN0UG9zaXRpb24gfHwgXCI1MCUgNTAlXCIsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kUmVwZWF0OiBcIm5vLXJlcGVhdFwiLFxuICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlOiBgdXJsKFwiJHthdXRvbWF0aWNhbGx5Q2FsY3VsYXRlZEJsdXJEYXRhVVJMfVwiKWAsXG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgaXNTdGF0aWNJbWFnZSA9IHR5cGVvZiBzcmMgPT09IFwib2JqZWN0XCI7XG4gICAgbGV0IF9zcmMgPSBpc1N0YXRpY0ltYWdlID8gc3JjLnNyYyA6IHNyYztcbiAgICBpZiAoYmFzZVBhdGggJiYgIWlzU3RhdGljSW1hZ2UgJiYgX3NyYy5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgICBfc3JjID0gYmFzZVBhdGggKyBfc3JjO1xuICAgIH1cbiAgICBpZiAoYmFzZVBhdGggJiYgIWlzU3RhdGljSW1hZ2UgJiYgIV9zcmMuc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgX3NyYyA9IGJhc2VQYXRoICsgXCIvXCIgKyBfc3JjO1xuICAgIH1cbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW1hZ2UsIHsgcmVmOiByZWYsIGFsdDogYWx0LCAuLi5yZXN0LCAuLi4od2lkdGggJiYgeyB3aWR0aCB9KSwgLi4uKGhlaWdodCAmJiB7IGhlaWdodCB9KSwgLi4uKGxvYWRpbmcgJiYgeyBsb2FkaW5nIH0pLCAuLi4oY2xhc3NOYW1lICYmIHsgY2xhc3NOYW1lIH0pLCAuLi4ob25Mb2FkICYmIHsgb25Mb2FkIH0pLCAuLi4ob3ZlcnJpZGVTcmMgJiYgeyBvdmVycmlkZVNyYyB9KSwgLi4uKHBsYWNlaG9sZGVyICYmIHtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBibHVyU3R5bGUgfHwgYmx1ckNvbXBsZXRlID8gXCJlbXB0eVwiIDogcGxhY2Vob2xkZXIsXG4gICAgICAgIH0pLCAuLi4odW5vcHRpbWl6ZWQgJiYgeyB1bm9wdGltaXplZCB9KSwgLi4uKHByaW9yaXR5ICYmIHsgcHJpb3JpdHkgfSksIC4uLihpc1NWRyAmJiB7IHVub3B0aW1pemVkOiB0cnVlIH0pLCBzdHlsZTogeyAuLi5zdHlsZSwgLi4uYmx1clN0eWxlIH0sIGxvYWRlcjogaW1hZ2VFcnJvciB8fCB1bm9wdGltaXplZCA9PT0gdHJ1ZVxuICAgICAgICAgICAgPyAoKSA9PiBmYWxsYmFja0xvYWRlcih7IHNyYzogb3ZlcnJpZGVTcmMgfHwgc3JjIH0pXG4gICAgICAgICAgICA6IChlKSA9PiBvcHRpbWl6ZWRMb2FkZXIoeyBzcmMsIHdpZHRoOiBlLndpZHRoLCBiYXNlUGF0aCB9KSwgYmx1ckRhdGFVUkw6IGF1dG9tYXRpY2FsbHlDYWxjdWxhdGVkQmx1ckRhdGFVUkwsIG9uRXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgc2V0SW1hZ2VFcnJvcih0cnVlKTtcbiAgICAgICAgICAgIHNldEJsdXJDb21wbGV0ZSh0cnVlKTtcbiAgICAgICAgICAgIC8vIGV4ZWN1dGUgdGhlIG9uRXJyb3IgZnVuY3Rpb24gaWYgcHJvdmlkZWRcbiAgICAgICAgICAgIG9uRXJyb3IgJiYgb25FcnJvcihlcnJvcik7XG4gICAgICAgIH0sIG9uTG9hZDogKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGZvciBzb21lIGNvbmZpZ3VyYXRpb25zLCB0aGUgb25FcnJvciBoYW5kbGVyIGlzIG5vdCBjYWxsZWQgb24gYW4gZXJyb3Igb2NjdXJyZW5jZVxuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBjaGVjayBpZiB0aGUgaW1hZ2UgaXMgbG9hZGVkIGNvcnJlY3RseVxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICBpZiAodGFyZ2V0Lm5hdHVyYWxXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEJyb2tlbiBpbWFnZSwgZmFsbCBiYWNrIHRvIHVub3B0aW1pemVkIChtZWFuaW5nIHRoZSBvcmlnaW5hbCBpbWFnZSBzcmMpXG4gICAgICAgICAgICAgICAgc2V0SW1hZ2VFcnJvcih0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEJsdXJDb21wbGV0ZSh0cnVlKTtcbiAgICAgICAgICAgIC8vIGV4ZWN1dGUgdGhlIG9uTG9hZCBjYWxsYmFjayBpZiBwcmVzZW50XG4gICAgICAgICAgICBvbkxvYWQgJiYgb25Mb2FkKGUpO1xuICAgICAgICB9LCBzcmM6IGlzU3RhdGljSW1hZ2UgPyBzcmMgOiBfc3JjIH0pKTtcbn0pO1xuRXhwb3J0ZWRJbWFnZS5kaXNwbGF5TmFtZSA9IFwiRXhwb3J0ZWRJbWFnZVwiO1xuZXhwb3J0IGRlZmF1bHQgRXhwb3J0ZWRJbWFnZTtcbiJdLCJuYW1lcyI6WyJJbWFnZSIsIlJlYWN0IiwiZm9yd2FyZFJlZiIsInVzZU1lbW8iLCJ1c2VTdGF0ZSIsInNwbGl0RmlsZVBhdGgiLCJmaWxlUGF0aCIsImZpbGVuYW1lV2l0aEV4dGVuc2lvbiIsInNwbGl0IiwicG9wIiwiZmlsZVBhdGhXaXRob3V0RmlsZW5hbWUiLCJzaGlmdCIsImZpbGVFeHRlbnNpb24iLCJmaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24iLCJzdWJzdHJpbmciLCJsYXN0SW5kZXhPZiIsInBhdGgiLCJmaWxlbmFtZSIsImV4dGVuc2lvbiIsImdlbmVyYXRlSW1hZ2VVUkwiLCJzcmMiLCJ3aWR0aCIsImJhc2VQYXRoIiwiaXNSZW1vdGVJbWFnZSIsInVzZVdlYnAiLCJwcm9jZXNzIiwiZW52IiwibmV4dEltYWdlRXhwb3J0T3B0aW1pemVyX3N0b3JlUGljdHVyZXNJbldFQlAiLCJ1bmRlZmluZWQiLCJpbmNsdWRlcyIsInRvVXBwZXJDYXNlIiwicHJvY2Vzc2VkRXh0ZW5zaW9uIiwiY29ycmVjdGVkUGF0aCIsImxhc3RDaGFyIiwic3Vic3RyIiwiaXNTdGF0aWNJbWFnZSIsImVuZHNXaXRoIiwic3RhcnRzV2l0aCIsInNsaWNlIiwiZXhwb3J0Rm9sZGVyTmFtZSIsIm5leHRJbWFnZUV4cG9ydE9wdGltaXplcl9leHBvcnRGb2xkZXJOYW1lIiwiYmFzZVBhdGhQcmVmaXhGb3JTdGF0aWNJbWFnZXMiLCJnZW5lcmF0ZWRJbWFnZVVSTCIsImNoYXJBdCIsImhhc2hBbGdvcml0aG0iLCJzdHIiLCJzZWVkIiwiaDEiLCJoMiIsImkiLCJjaCIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJNYXRoIiwiaW11bCIsInVybFRvRmlsZW5hbWUiLCJ1cmwiLCJwYXJzZWRVcmwiLCJVUkwiLCJwYXRobmFtZSIsInRvU3RyaW5nIiwiY29uY2F0IiwiZXJyb3IiLCJjb25zb2xlIiwiaW1hZ2VVUkxGb3JSZW1vdGVJbWFnZSIsImVuY29kZWRTcmMiLCJvcHRpbWl6ZWRMb2FkZXIiLCJfc3JjIiwib3JpZ2luYWxJbWFnZVdpZHRoIiwiZGV2aWNlU2l6ZXMiLCJfX05FWFRfSU1BR0VfT1BUUyIsIm1hcCIsIk51bWJlciIsImltYWdlU2l6ZXMiLCJhbGxTaXplcyIsImZpbHRlciIsInYiLCJhIiwiaW5kZXhPZiIsInNvcnQiLCJiIiwibmV4dExhcmdlc3RTaXplIiwiZmFsbGJhY2tMb2FkZXIiLCJFeHBvcnRlZEltYWdlIiwicHJpb3JpdHkiLCJsb2FkaW5nIiwiY2xhc3NOYW1lIiwiaGVpZ2h0Iiwib25Mb2FkIiwidW5vcHRpbWl6ZWQiLCJwbGFjZWhvbGRlciIsImFsdCIsImJsdXJEYXRhVVJMIiwic3R5bGUiLCJvbkVycm9yIiwib3ZlcnJpZGVTcmMiLCJyZXN0IiwicmVmIiwiaW1hZ2VFcnJvciIsInNldEltYWdlRXJyb3IiLCJhdXRvbWF0aWNhbGx5Q2FsY3VsYXRlZEJsdXJEYXRhVVJMIiwiaXNTVkciLCJibHVyQ29tcGxldGUiLCJzZXRCbHVyQ29tcGxldGUiLCJibHVyU3R5bGUiLCJiYWNrZ3JvdW5kU2l6ZSIsIm9iamVjdEZpdCIsImJhY2tncm91bmRQb3NpdGlvbiIsIm9iamVjdFBvc2l0aW9uIiwiYmFja2dyb3VuZFJlcGVhdCIsImJhY2tncm91bmRJbWFnZSIsImNyZWF0ZUVsZW1lbnQiLCJsb2FkZXIiLCJlIiwidGFyZ2V0IiwibmF0dXJhbFdpZHRoIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next-image-export-optimizer/dist/ExportedImage.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next-image-export-optimizer/dist/ExportedImage.js":
/*!************************************************************************!*\
  !*** ./node_modules/next-image-export-optimizer/dist/ExportedImage.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/build/webpack/loaders/next-flight-loader/module-proxy */ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`C:\Root\Coding\Projects\addis-path-trailers\node_modules\next-image-export-optimizer\dist\ExportedImage.js#default`));


/***/ })

};
;